////////////////////////////////////////////////////////////////////////////////
/////////       Copyright 2015-2019 Joaquim Borges, Cristina            ////////
/////////          Fernández-Córdoba and Roger Ten-Valls                ////////
/////////                                                               ////////
/////////       This program is distributed under the terms of GNU      ////////
/////////               General Public License                          ////////
/////////                                                               ////////
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*******************************************************************************/


/*************************************************************/
/*                                                           */
/* Project name: Z2Z4-additive codes in MAGMA                */
/* File name: Z2Z4Cyclic.m                                   */
/*                                                           */
/* Comment: Package developed within the CCSG group          */
/*                                                           */
/* Authors: Joaquim Borges, Cristina                         */
/*          Fernández-Córdoba and Roger Ten-Valls            */
/*          and suppervised by J. Pujol and M. Villanueva    */
/*                                                           */
/* Revision version and last date: v1.0   26-10-2015         */
/*                                 v1.1   04-02-2016         */
/*                                 v1.2   23-02-2016         */
/*                                 v1.3   27-07-2016         */
/*                                 v1.4   26-01-2018         */
/*    User defined type            v1.5   30-01-2019         */
/*                                                           */
/*************************************************************/
//Uncomment freeze when package finished
freeze;

intrinsic Z2Z4Cyclic_version() -> SeqEnum
{Return the current version of this package.}
    
    version := [1, 5];
    return version;

end intrinsic;

//needs Z2Z4AdditiveCode.m file
//needs Z2Z4StandardForm.m file

/****************************************************************
    GLOBAL VARIABLES
*****************************************************************/
    
Z2 := Integers(2);
Z4 := Integers(4);
PR2<x> := PolynomialRing(Integers(2)); 
PR4<y> := PolynomialRing(Z4);
PR<z> := PolynomialRing(Integers());

////////////////////////////////////////////////////////////////////////////////
///////// Functions we need from Z2Z4AdditiveCode.m package ////////////////////
////////////////////////////////////////////////////////////////////////////////

import "Z2Z4AdditiveCodes.m": IsZ2Z4AlphaOverZ4,  
                              Z2Z4AlphaFromZ4toZ2,
                              FromSeqZ2Z4toZ4,
                              FromVectorZ2Z4toZ4;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///////                     CYCLIC CODE FUNCTIONS                       ////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/****************************************************************/
/*                                                              */
/* Function name: SpanningSeqCyclicCode                         */
/* Parameters:  alpha, beta, n, M                               */
/* Function description: Given three non-negative integers      */
/*   alpha, beta and n, and a non-empty matrix M over Z4,       */
/*   construct the Z2Z4-additive cyclic code of type            */
/*   (alpha, beta; gamma, delta; kappa) generated by the double */
/*   right cyclic shifts of the rows of M.                      */
/*                                                              */
/****************************************************************/ 
function SpanningSeqCyclicCode(alpha, beta, n, M)
    
    V := RSpace(Z4, n);
    lcm_alpha_beta := (IsZero(alpha) or IsZero(beta)) select Max(alpha, beta) 
                                                          else LCM(alpha, beta);
    spanningSeq := [];
    for v in Rows(M) do
        v_x := [v[i] : i in [1 .. alpha]];
        v_y := [v[i] : i in [alpha + 1 .. n]];
        spanningSeq cat:= [V!(Rotate(v_x, i) cat Rotate(v_y, i)) :
                                                    i in [1 .. lcm_alpha_beta]];
    end for;
    return Z2Z4AdditiveCode(spanningSeq, alpha);

end function;

/****************************************************************/
/*                                                              */
/* Function name: PolynomialToSequence                          */
/* Parameters:  alpha, beta, n, G                               */
/* Function description: Given three non-negative integers      */
/*   alpha, beta and n, and a non-empty sequence G containing   */
/*   r tuples of polynomials, that is  G=[< a_1(x), b_1(x)>,...,*/
/*   <a_r(x), b_r(x)>], where a_i(x) in Z2[x] and b_i(x) in     */
/*   Z4[x], for 1<= i <= r, return the sequence of coefficients */
/*   vectors of length n of the given tuples of polynomials.    */
/*                                                              */
/****************************************************************/ 
function PolynomialToSequence(alpha, beta, n, G)

    numGenerators := #G; 
    for i in [1 .. numGenerators] do
        G[i][1] := (IsZero(alpha)) select PR2!0 
                                   else (G[i][1]) mod (x^alpha - 1);
        G[i][2] := (IsZero(beta)) select PR4!0 
                                   else (G[i][2]) mod (y^beta - 1);
    end for;

    V := RSpace(Z4, n); 
    spanningSeq := [V!([ 2*(Z4!Coefficient(G[i][1], j)) : j in [0 .. alpha - 1]] 
                        cat [ Coefficient(G[i][2], k) : k in [0 .. beta - 1]]) :
                                                     i in [1 .. numGenerators]];
    return spanningSeq;

end function;

/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters:  alpha, G                                        */
/* Function description: Given a non-negative integer alpha and */
/*   a non-empty sequence of r vectors G=[u_1,u_2,...,u_r],     */
/*   where,  for 1<= i<= r, u_i in Z2^alpha x Z4^beta is        */
/*   represented as an element in Z4^(alpha+beta) by replacing  */
/*   the ones in the first alpha coordinates by twos, construct */
/*   the Z2Z4-additive cyclic code of type (alpha, beta; gamma, */
/*   delta; kappa) generated by the double right cyclic shifts  */
/*   of the vectors u_1,u_2,...,u_r. It is checked whether the  */
/*   elements in the first alpha coordinates are in {0, 2}.     */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - G : A sequence of vectors over Z4                        */
/* Output parameters description:                               */
/*   - A record representing a Z2Z4-additive code               */
/*                                                              */
/* Signature: (<RngIntElt> alpha, <[ModTupRngElt]> G) -> Z2Z4Code*/
/*                                                              */
/****************************************************************/ 
intrinsic Z2Z4CyclicCode(alpha::RngIntElt, G::[ModTupRngElt]) -> Z2Z4Code
{
Given a non-negative integer alpha and a non-empty sequence of r vectors 
G=[u_1,u_2,...,u_r], where,  for 1<= i<= r, u_i in Z2^alpha x Z4^beta is 
represented as an element in Z4^(alpha+beta) by replacing the ones in the 
first alpha coordinates by twos, construct the Z2Z4-additive cyclic code 
of type (alpha, beta; gamma, delta; kappa) generated by the double right 
cyclic shifts of the vectors u_1,u_2,...,u_r. It is checked whether the 
elements in the first alpha coordinates are in the set [0, 2].
}
    require not(IsEmpty(G)) : "Argument 2 cannot be empty";
    require (BaseRing(G[1]) eq Z4) : 
                                  "Argument 2 does not contain vectors over Z4"; 
    n := Degree(G[1]);
    require n gt 0 : "Argument 2 must contain vectors of length greater than 0";
    requirerange alpha, 0, n;
    
    M := Matrix(G);
    require IsZ2Z4AlphaOverZ4(M, alpha):
                         "First", alpha, "coordinates must be in the set {0,2}";

    return SpanningSeqCyclicCode(alpha, n - alpha, n, M);

end intrinsic; 

/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters:  G                                               */
/* Function description: Given a non-empty sequence of r vectors*/
/*   G=[u_1,u_2,...,u_r], where,  for 1<= i<= r, u_i in Z2^alpha*/
/*   x Z4^beta is represented as a tuple in the cartesian       */
/*   product set Z2^alpha x Z4^beta,construct the Z2Z4-additive */
/*   cyclic code of type (alpha, beta; gamma, delta; kappa)     */
/*   generated by the double right cyclic shifts of the vectors */
/*   u_1,u_2,...,u_r.                                           */
/* Input parameters description:                                */
/*   - G : A sequence of vectors over Z2^alpha x Z4^beta        */
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature: (<SeqEnum> G) -> Z2Z4Code                         */
/*                                                              */
/****************************************************************/ 
intrinsic Z2Z4CyclicCode(G::SeqEnum) -> Z2Z4Code
{
Given a non-empty sequence of r vectors G=[u_1,u_2,...,u_r], where,  
for 1<= i<= r, u_i in Z2^alpha x Z4^beta is represented as a tuple in the cartesian 
product set Z2^alpha x Z4^beta, construct the Z2Z4-additive 
cyclic code of type (alpha, beta; gamma, delta; kappa) generated by 
the double right cyclic shifts of the vectors u_1,u_2,...,u_r.
}
    require not(IsEmpty(G)): "Argument 1 cannot be empty";
    require ElementType(G) cmpeq Tup: "Argument 1 does not contain tuples over Z2 x Z4";  
    require #G[1] eq 2: "Argument 1 is not an element of the cartesian product Z2^alpha x Z4^beta";
    require Type(G[1][1]) cmpeq  ModTupRngElt and Type(G[1][2]) cmpeq ModTupRngElt: 
            "Argument 1 is not an element of the cartesian product Z2^alpha x Z4^beta";
    require (BaseRing(G[1][2]) cmpeq Z4 and BaseRing(G[1][1]) cmpeq Z2): 
            "Argument 1 is not an element of the cartesian product Z2^alpha x Z4^beta"; 

    alpha := Ncols(G[1][1]);
    beta := Ncols(G[1][2]);
    n := alpha + beta;
    require n gt 0 : "Argument 1 must contain vectors of length greater than 0";

    M := FromSeqZ2Z4toZ4(G);

    return SpanningSeqCyclicCode(alpha, beta, n, M);

end intrinsic; 

/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: alpha, u                                         */
/* Function description: Given a non-negative integer alpha and */
/*   a vector u=(u_alpha | u_beta) in Z2^alpha x Z4^beta,       */
/*   represented as an element in Z4^(alpha+beta) by replacing  */
/*   the ones in the first alpha coordinates by twos, construct */
/*   the Z2Z4-additive cyclic code of type (alpha, beta; gamma, */
/*   delta; kappa) generated by the double right cyclic shifts  */
/*   of the vector u. It is checked whether the elements in the */
/*   first alpha coordinates are in {0, 2}.                     */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - u : A vector over Z4                                     */ 
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature: (<RngIntElt> alpha, <ModTupRngElt> u) -> Z2Z4Code */
/*                                                              */
/****************************************************************/ 
intrinsic Z2Z4CyclicCode(alpha::RngIntElt, u::ModTupRngElt) -> Z2Z4Code
{
Given a non-negative integer alpha and a vector u=(u_alpha | u_beta) 
in Z2^alpha x Z4^beta, represented as an element in Z4^(alpha+beta) by 
replacing the ones in the first alpha coordinates by twos, construct the 
Z2Z4-additive cyclic code of type (alpha, beta; gamma, delta; kappa) 
generated by the double right cyclic shifts of the vector u. It is checked 
whether the elements in the first alpha coordinates are in the set [0, 2].
}   
    require (BaseRing(u) eq Z4) : "Argument 2 is not a vector over Z4"; 

    n := Degree(u);
    require n gt 0 : "Argument 2 must be a vector of length greater than 0";
    requirerange alpha, 0, n;

    M := Matrix(u);
    require IsZ2Z4AlphaOverZ4(M, alpha):
                        "First", alpha, "coordinates must be in the set {0, 2}";

    return SpanningSeqCyclicCode(alpha, n - alpha, n, M);

end intrinsic; 

/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: u                                                */
/* Function description: Given a vector u=<u_alpha | u_beta> in */
/*   Z2^alpha x Z4^beta, represented as a tuple in the cartesian*/
/*   product set Z2^alpha x Z4^beta,construct the Z2Z4-additive */
/*   cyclic code of type (alpha, beta; gamma, delta; kappa)     */
/*   generated by the double right cyclic shifts of the vector u*/
/* Input parameters description:                                */
/*   - u : A vector over Z2^alpha x Z4^beta                     */ 
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature: (<Tup> u) -> Z2Z4Code                             */
/*                                                              */
/****************************************************************/ 
intrinsic Z2Z4CyclicCode(u::Tup) -> Z2Z4Code
{
Given a vector u=<u_alpha | u_beta> in Z2^alpha x Z4^beta, represented as a 
tuple in the cartesian product set Z2^alpha x Z4^beta, construct 
the Z2Z4-additive cyclic code of type (alpha, beta; gamma, delta; kappa) 
generated by the double right cyclic shifts of the vector u.
}   
    require #u eq 2: "Argument 1 is not an element of the cartesian product Z2^alpha x Z4^beta";
    require Type(u[1]) cmpeq  ModTupRngElt and Type(u[2]) cmpeq ModTupRngElt: 
            "Argument 1 is not an element of the cartesian product Z2^alpha x Z4^beta";
    require (BaseRing(u[2]) cmpeq Z4 and BaseRing(u[1]) cmpeq Z2): 
            "Argument 1 is not an element of the cartesian product Z2^alpha x Z4^beta";
    
    alpha := Ncols(u[1]);
    beta := Ncols(u[2]);

    n := alpha + beta;
    require n gt 0 : "Argument 1 must be a vector of length greater than 0";

    M := Matrix(FromVectorZ2Z4toZ4(u));

    return SpanningSeqCyclicCode(alpha, beta, n, M);

end intrinsic; 

/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: alpha, beta, G                                   */
/* Function description: Given two non-negative integers alpha  */
/*   and beta, and a non-empty sequence G containing r tuples   */
/*   of polynomials, that is  G=[< a_1(x), b_1(x)>,..., <a_r(x),*/
/*   b_r(x)>], where a_i(x) in Z2[x] and b_i(x) in Z4[x], for   */
/*   1<= i <= r, construct the Z2Z4-additive cyclic code of     */
/*   type (alpha, beta; gamma, delta; kappa) generated by       */
/*   (a_1(x) | b_1(x)),...,(a_r(x) | b_r(x)).                   */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : A non-negative integer                            */
/*   - G : A sequence of tuples of generator polynomials        */
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */  
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta, <[Tup]> G)  */
/*                 -> Z2Z4Code                                  */
/*                                                              */
/****************************************************************/ 
intrinsic Z2Z4CyclicCode(alpha::RngIntElt, beta::RngIntElt, G::[Tup]) -> Z2Z4Code
{
Given two non-negative integers alpha and beta, and a non-empty sequence G 
containing r tuples of polynomials, that is  G=[< a_1(x), b_1(x)>,..., 
<a_r(x), b_r(x)>], where a_i(x) in Z2[x] and b_i(x) in Z4[x], for 1<= i <= r, 
construct the Z2Z4-additive cyclic code of type (alpha, beta; gamma, delta; 
kappa) generated by (a_1(x) | b_1(x)),...,(a_r(x) | b_r(x)). 
}   
    requirege alpha, 0; 
    requirege beta, 0;

    n := alpha + beta;    
    require (n gt 0) : "Argument 1 and argument 2 cannot be both 0";    
    require (Parent(G[1][1]) cmpeq PR2) : 
      "Not all the first entry of tuples in argument 3 are polynomials over Z2";
    require (Parent(G[1][2]) cmpeq PR4) : 
     "Not all the second entry of tuples in argument 3 are polynomials over Z4";

    spanningSeq := PolynomialToSequence(alpha, beta, n, G);

    return SpanningSeqCyclicCode(alpha, beta, n, Matrix(spanningSeq));

end intrinsic;  

/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: alpha, beta, p, l, f, h                          */
/* Function description: Given two non-negative integers alpha  */
/*   and beta, and four polynomials p(x), l(x), f(x) and h(x),  */
/*   such that p(x), l(x) in Z2[x] and f(x), h(x) in Z4[x],     */
/*   construct the Z2Z4-additive cyclic code of type (alpha,    */
/*   beta; gamma, delta; kappa) generated by (p(x) | 0) and     */
/*   (l(x) | f(x)h(x) + 2f(x)).                                 */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : A non-negative integer                            */
/*   - p : A polynomial over Z2                                 */
/*   - l : A polynomial over Z2                                 */ 
/*   - f : A polynomial over Z4                                 */
/*   - h : A polynomial over Z4                                 */  
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta,             */
/*             <RngUPolElt> p, <RngUPolElt> l, <RngUPolElt> f,  */
/*             <RngUPolElt> h) -> Z2Z4Code                      */
/*                                                              */
/****************************************************************/ 
intrinsic Z2Z4CyclicCode(alpha::RngIntElt, beta::RngIntElt, p::RngUPolElt, 
                     l::RngUPolElt, f::RngUPolElt, h::RngUPolElt) -> Z2Z4Code
{
Given two non-negative integers alpha and beta, and four polynomials p(x), l(x), 
f(x) and h(x), such that p(x), l(x) in Z2[x] and f(x), h(x) in Z4[x], construct 
the Z2Z4-additive cyclic code of type (alpha, beta; gamma, delta; kappa) 
generated by (p(x) | 0) and (l(x) | f(x)h(x) + 2f(x)).
}   
    requirege alpha, 0; 
    requirege beta, 0;

    n := alpha + beta;
    require (n gt 0) : "Argument 1 and argument 2 cannot be both 0";
    require (Parent(p) cmpeq PR2) and (Parent(l) cmpeq PR2) :
                            "Arguments 3 and 4 are not all polynomials over Z2";
    require (Parent(f) cmpeq PR4) and (Parent(h) cmpeq PR4) :
                            "Arguments 5 and 6 are not all polynomials over Z4";
   
    spanningSeq := PolynomialToSequence(alpha, beta, n, [<p, PR4!0>,           
                                                               <l, f*h + 2*f>]);

    return SpanningSeqCyclicCode(alpha, beta, n, Matrix(spanningSeq));

end intrinsic;  

/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: alpha, beta, a, b                                */
/* Function description: Given two non-negative integers alpha  */ 
/*   and beta, and two polynomials a(x) in Z2[x] and b(x) in    */
/*   Z4[x], construct the Z2Z4-additive cyclic code of type     */
/*   (alpha, beta; gamma, delta; kappa) generated by            */
/*   (a(x) | b(x)).                                             */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : A non-negative integer                            */
/*   - a : A polynomial over Z2                                 */
/*   - b : A polynomial over Z4                                 */ 
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta,             */
/*             <RngUPolElt> a, <RngUPolElt> b) -> Z2Z4Code      */
/*                                                              */
/****************************************************************/ 
intrinsic Z2Z4CyclicCode(alpha::RngIntElt, beta::RngIntElt, 
                     a::RngUPolElt, b::RngUPolElt) -> Z2Z4Code
{
Given two non-negative integers alpha and beta, and two polynomials a(x) in 
Z2[x] and b(x) in Z4[x], construct the Z2Z4-additive cyclic code of type 
(alpha, beta; gamma, delta; kappa) generated by (a(x) | b(x)).
}   
    requirege alpha, 0; 
    requirege beta, 0;

    n := alpha + beta;
    require (n gt 0) : "Argument 1 and argument 2 cannot be both 0";
    require (Parent(a) cmpeq PR2) : "Arguments 3 is not a polynomial over Z2";
    require (Parent(b) cmpeq PR4) : "Arguments 4 is not a polynomials over Z4";
   
    spanningSeq := PolynomialToSequence(alpha, beta, n, [<a, b>]);

    return SpanningSeqCyclicCode(alpha, beta, n, Matrix(spanningSeq));

end intrinsic;  

/****************************************************************/
/*                                                              */
/* Function name: IsCyclic                                      */
/* Parameters: C                                                */
/* Function description: Return true if and only if the         */
/*   Z2Z4-additive code C is cyclic.                            */
/* Input parameters description:                                */
/*   - C : A Z2Z4-additive code                                 */
/* Output parameters description:                               */
/*   - Boolean, true if the Z2Z4-additive code is cyclic and    */
/*       false otherwise.                                       */
/*                                                              */
/* Signature: (<Z2Z4Code> C) -> BoolElt                         */
/*                                                              */
/****************************************************************/ 
intrinsic IsCyclic(C::Z2Z4Code) -> BoolElt
{
Return true if and only if the Z2Z4-additive code C is cyclic.
}
    generatorMatrix := MinRowsGeneratorMatrix(C);
    alpha := C`Alpha;
    n := Length(C);
    V := RSpace(Z4, n);
    for v in Rows(generatorMatrix) do
        v_x := [v[i]: i in [1 .. alpha]];
        v_y := [v[i]: i in [alpha + 1 .. n]];
        if (V!(Rotate(v_x, 1) cat Rotate(v_y, 1))) notin C`Code then
            return false;
        end if;
    end for;

    return true;

end intrinsic;

/****************************************************************/
/*                                                              */
/* Function name: GeneratorPolynomials                          */
/* Parameters: C                                                */
/* Function description: Given a Z2Z4-additive cyclic code C of */
/*   type (alpha, beta; gamma, delta; kappa) with beta odd,     */
/*   return a tuple containing the generator polynomials        */
/*   < p(x), l(x), f(x), h(x) >, where p(x), l(x) in Z2[x] and  */
/*   f(x), h(x) in Z4[x], such that p(x) divides x^alpha - 1,   */
/*   deg(l(x)) < deg(p(x)), f(x) and h(x) are coprime divisors  */
/*   of x^beta-1, b(x) divides ((x^beta - 1)/f(x))l(x) (mod 2), */
/*   and C = < (p(x) | 0), (l(x) | f(x)h(x) + 2f(x)) >.         */
/* Input parameters description:                                */
/*   - C : A Z2Z4-additive cyclic code                          */
/* Output parameters description:                               */
/*   - A tuple with the polynomials < p(x), l(x), f(x), h(x) >, */
/*      that is, the generator polynomials of the code          */
/*                                                              */
/* Remark: This function is based on the results given in the   */
/*         following papers:                                    */  
/*   - "Z2Z4-additive cyclic codes, generator polynomials, and  */
/*     dual codes" by J. Borges, C. Fernández-Córdoba, and      */
/*     R. Ten-Valls in IEEE Transactions on Information Theory, */
/*     vol. 62, no 11, 2016.                                    */
/*   - "Computing the generator polynomials of Z2Z4-additive    */
/*     cyclic codes" y J. Borges, C. Fernández-Córdoba, and     */
/*     R. Ten-Valls, arXiv:1606.01745                           */
/*                                                              */
/* Signature: (<Z2Z4Code> C) -> Tup                                  */
/*                                                              */
/****************************************************************/ 
intrinsic GeneratorPolynomials(C::Z2Z4Code) -> Tup
{
Given a Z2Z4-additive cyclic code C of type (alpha, beta; gamma, delta; kappa) 
with beta odd, return a tuple containing the generator polynomials 
< p(x), l(x), f(x), h(x) >, where p(x), l(x) in Z2[x] and f(x), h(x) in Z4[x], 
such that p(x) divides x^alpha - 1, deg(l(x)) < deg(p(x)), f(x) and h(x) are 
coprime divisors of x^beta - 1, b(x) divides ((x^beta - 1)/f(x))l(x) (mod 2), 
and C = < (p(x) | 0), (l(x) | f(x)h(x) + 2f(x)) >.
}
    require IsCyclic(C) : "Code C is not a Z2Z4-additive cyclic code";
    
    alpha := C`Alpha;
    n := Length(C);
    beta := n - alpha;
    require (IsOdd(beta) or IsZero(beta)) : "The length of the quaternary part must be zero or odd";

    if beta gt 0 then
        C4 := LinearQuaternaryCode(C);

        ////////// Polynomial F over Z2 /////////
        binaryF := GeneratorPolynomial(BinaryTorsionCode(C4));
        if IsZero(binaryF) then
            binaryF := x^beta - 1;
        end if;    

        ////////// Polynomial H over Z2/////////
        binaryFH := GeneratorPolynomial(BinaryResidueCode(C4));
        if IsZero(binaryFH) then
            binaryFH := x^beta - 1;
        end if;    
        binaryH := PR2!binaryFH div PR2!binaryF;

        ///////// Hensel Lift F and H ///////////
        seqOfFactors := [w[1] : w in Factorization(x^beta - 1)];
        henselLift := HenselLift(z^beta - 1, seqOfFactors, PR4);    
        factBinaryF := [w[1] : w in Factorization(binaryF)];
        factQuaternaryF := [PR4!1];
        factBinaryH := [w[1] : w in Factorization(binaryH)];
        factQuaternaryH := [PR4!1];
        for q in henselLift do
            if PR2!q in factBinaryF then
                Append(~factQuaternaryF, q);
            end if;
            if PR2!q in factBinaryH then
                Append(~factQuaternaryH, q);
            end if;
        end for;
        polyF := &*factQuaternaryF;
        polyH := &*factQuaternaryH;
    else
        polyF := PR4!0;
        polyH := PR4!0;
    end if;

    if alpha gt 0 then
        ////////// Polynomial P /////////
        polyP := PR2!GeneratorPolynomial(BinaryTorsionCode(ShortenCode(C, 
                                                         {alpha + 1 .. n})`Code));
        if IsZero(polyP) then
            polyP := x^alpha - 1;
        end if;

        ////////// Polynomial L /////////
        if beta gt 0 then
            if (polyF*polyH ne y^beta - 1) then    
                polyFH2F:= Coefficients(polyF*polyH + 2*polyF) cat 
                                          [0^^(beta - 1 - Degree(polyF*polyH))];
            elif (polyF ne y^beta - 1) then
                polyFH2F := Coefficients(2*polyF) cat [0^^(beta - 1 - Degree(polyF))];
            else
                polyFH2F := [0^^beta];
            end if;

            GenMat := MinRowsGeneratorMatrix(C);
            numRowsGenMat := NumberOfRows(GenMat);
            if IsZero(numRowsGenMat) then
                return <polyP, PR2!0, polyF, polyH>;
            end if;

            /// Quaternary submatrix, Gq, of the generator matrix GenMat ///
            quaternaryCoordGenMat := ColumnSubmatrix(GenMat, alpha + 1, beta);

            /// Equivalent matrix of Gq and its row transformation in Echelon Form ///
            quaternaryCoordEchelonMat, EchelonMatToGenMat := 
                                             EchelonForm(quaternaryCoordGenMat);
            /// Coordinates of the polynomial FH2F over the equivalent matrix///
            coordFH2FEchelonMat := Coordinates(LinearCode(quaternaryCoordEchelonMat), 
                                                          Vector(Z4, polyFH2F));
            /// Coordinates, u, of the polynomial FH2F over Gq ///
            coordFH2FEchelonMat := coordFH2FEchelonMat cat 
                                        [0^^(numRowsGenMat - #coordFH2FEchelonMat)];
            coordFH2FGenMat := Vector(coordFH2FEchelonMat)*EchelonMatToGenMat;
            /// Codeword, v, such that v = (L | FH2F) = u*GenMat ///
            codewordL4FH2F := Vector(coordFH2FGenMat)*GenMat;

            polyL4 := PR4!Eltseq(codewordL4FH2F)[1..alpha];
            polyL := (PR2![Z2Z4AlphaFromZ4toZ2(Coefficient(polyL4, i)) : 
                                         i in [0 .. Degree(polyL4)]]) mod polyP;
        else
            polyL := PR2!0;       
        end if;
    else
        polyP := PR2!0;
        polyL := PR2!0;
    end if;

    return <polyP, polyL, polyF, polyH>;

end intrinsic;

/****************************************************************/
/*                                                              */
/* Function name: DualGeneratorPolynomials                      */
/* Parameters: C                                                */
/* Function description: Given a Z2Z4-additive cyclic code C of */
/*   type (alpha, beta; gamma, delta; kappa) with beta odd,     */
/*   return a tuple of polynomials <p'(x), l'(x), f'(x), h'(x)>,*/
/*   where p'(x), l'(x) in Z2[x] and f'(x), h'(x) in Z4[x], such*/
/*   that p'(x) divides x^alpha - 1, deg(l'(x)) < deg(p'(x)),   */
/*   f'(x) and h'(x) are coprime divisors of x^beta-1, p'(x)    */
/*   divides ((x^beta - 1)/f'(x))l'(x) (mod 2). These           */
/*   polynomials are the generator polynomials of the additive  */
/*   dual code of C.                                            */
/* Input parameters description:                                */
/*   - C : A Z2Z4-additive cyclic code                          */
/* Output parameters description:                               */
/*   - A tuple of polynomials <p'(x),l'(x),f'(x),h'(x)>,        */
/*      containing the generator polynomials of the additive    */
/*      dual of C.                                              */
/*                                                              */
/* Remark: This function is based on the results given in the   */
/*   paper "Z2Z4-additive cyclic codes, generator polynomials,  */
/*   and dual codes" by J. Borges, C. Fernández-Córdoba, and R. */
/*   Ten-Valls in IEEE Transactions on Information Theory,      */
/*   vol. 62, no 11, 2016.                                      */
/*                                                              */
/* Signature: (<Z2Z4Code> C) -> Tup                             */
/*                                                              */
/****************************************************************/ 
intrinsic DualGeneratorPolynomials(C::Z2Z4Code) -> Tup
{
Given a Z2Z4-additive cyclic code C of type (alpha, beta; gamma, delta; kappa)
with beta odd, return a tuple of polynomials < p'(x), l'(x), f'(x), h'(x) >,
where p'(x), l'(x) in Z2[x] and  f'(x), h'(x) in Z4[x], such that p'(x) divides
x^alpha - 1, deg(l'(x)) < deg(p'(x)), f('x) and h'(x) are coprime divisors of
x^beta-1, p'(x) divides ((x^beta - 1)/f'(x))l'(x) (mod 2). These polynomials 
are the generator polynomials of the additive dual code of C.
}   
    return GeneratorPolynomials(Dual(C));    

end intrinsic;  

/****************************************************************/
/*                                                              */
/* Function name: DualGeneratorPolynomials                      */
/* Parameters: alpha, beta, p, l, f, h                          */
/* Function description: Given two non-negative integers alpha  */
/*   and beta, with beta odd, and four polynomials p(x), l(x),  */ 
/*   f(x) and h(x), such that p(x), l(x) in Z2[x] and f(x),     */
/*   h(x) in Z4[x], return a tuple of polynomials <p'(x), l'(x),*/
/*   f'(x), h'(x)>, where p'(x), l'(x) in Z2[x] and f'(x), h'(x)*/
/*   in Z4[x], such that p'(x) divides x^alpha - 1, deg(l'(x)) <*/
/*   deg(p'(x)), f'(x) and h'(x) are coprime divisors of        */
/*   x^beta-1 and p'(x) divides ((x^beta-1)/f'(x))l'(x) (mod 2).*/
/*   These polynomials are the generator polynomials of the     */
/*   additive dual code of C.                                   */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : A non-negative integer                            */
/*   - p : A polynomial over Z2                                 */
/*   - l : A polynomial over Z2                                 */ 
/*   - f : A polynomial over Z4                                 */
/*   - h : A polynomial over Z4                                 */  
/* Output parameters description:                               */
/*   - A tuple of polynomials < p'(x),l'(x),f'(x),h'(x) >,      */
/*      containing the generator polynomials of the additive    */
/*      dual of C.                                              */
/*                                                              */
/* Remark: This function is based on the results given in the   */
/*   paper "Z2Z4-additive cyclic codes, generator polynomials,  */
/*   and dual codes" by J. Borges, C. Fernández-Córdoba, and R. */
/*   Ten-Valls in IEEE Transactions on Information Theory,      */
/*   vol. 62, no 11, 2016.                                      */  
/*                                                              */
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta,             */
/*             <RngUPolElt> p, <RngUPolElt> l, <RngUPolElt> f,  */
/*             <RngUPolElt> h) -> Tup                           */
/*                                                              */
/****************************************************************/ 
intrinsic DualGeneratorPolynomials(alpha::RngIntElt, beta::RngIntElt, p::RngUPolElt, 
                             l::RngUPolElt, f::RngUPolElt, h::RngUPolElt) -> Tup
{
Given two non-negative integers alpha and beta, with beta odd, and four 
polynomials p(x), l(x), f(x) and h(x), such that p(x), l(x) in Z2[x] and f(x), 
h(x) in Z4[x], return a tuple of polynomials < p'(x), 
l'(x), f'(x), h'(x) >, where p'(x), l'(x) in Z2[x] and  f'(x), h'(x) in Z4[x],
such that p'(x) divides x^alpha - 1, deg(l'(x)) < deg(p'(x)), f'(x) and h'(x)
are coprime divisors  of x^beta-1 and p'(x) divides ((x^beta - 1)/f'(x))l'(x) (mod 2).
These polynomials are the generator polynomials of the additive dual code of C.
}
    requirege alpha, 0; 
    requirege beta, 0;
    require (IsOdd(beta) or IsZero(beta)) : "The length of the quaternary part must be zero or odd";

    require (alpha + beta gt 0) : "Argument 1 and argument 2 cannot be both 0";
    require (Parent(p) cmpeq PR2) and (Parent(l) cmpeq PR2) :
                            "Arguments 3 and 4 are not all polynomials over Z2";
    require (Parent(f) cmpeq PR4) and (Parent(h) cmpeq PR4) :
                            "Arguments 5 and 6 are not all polynomials over Z4";
    if IsZero(beta) then 
        require IsZero(f) : "Arguments 5 must be 0";
        require IsZero(h) : "Arguments 6 must be 0";
    else 
        require IsZero((y^beta - 1) mod f) : "Arguments 5 does not divide x^beta-1";
        require IsZero((y^beta - 1) mod h) : "Arguments 6 does not divide x^beta-1";
    end if;
       
    // Consider the polynomials in standard form //
    // p has to divide ((y^beta - 1)/f)*l (mod 2) //
    p := (beta gt 0) select PR2!Gcd(p,PR2!ExactQuotient(y^beta-1,f)*l) else p;
    g := (beta gt 0) select ExactQuotient(y^beta-1,f*h) else PR4!0;

    if IsZero(p) then   
        // p'(x) //
        pCheck := PR2!0;
        // f'(x) and h'(x) //
        fCheck := Normalize(ReciprocalPolynomial(g));
        hCheck := Normalize(ReciprocalPolynomial(h));

        // Delete if Normalize function is fixed to do this process
        if LeadingCoefficient(fCheck) eq 3 then
            fCheck := -fCheck;
        end if;
        if LeadingCoefficient(hCheck) eq 3 then
            hCheck := -hCheck;
        end if;

        // l'(x) //
        lCheck := PR2!0;
    else
        // Consider the polynomials in standard form: deg(l) < deg(p) //    
        l := l mod p;
        // p'(x) //
        pCheck := ExactQuotient(x^alpha-1, ReciprocalPolynomial(Gcd(p,l)));

        if IsZero(beta) then
            fCheck := PR4!0;
            hCheck := PR4!0;
            lCheck := PR2!0;
        else
            // f'(x) and h'(x) // 
            fCheckBinary := ReciprocalPolynomial(ExactQuotient(
                                                 PR2!g*Gcd(p, l), Gcd(p, l*PR2!g)));
            fhCheckBinary := ReciprocalPolynomial(ExactQuotient(
                                                  PR2!(g*h)*Gcd(p, l*PR2!g), p));
            seqOfFactors := [w[1] : w in Factorization(x^beta - 1)];
            henselLift := HenselLift(z^beta - 1, seqOfFactors, PR4);
            // Hensel Lift f and fh //
            factFCheckBinary := [w[1] : w in Factorization(fCheckBinary)];
            factFHCheckBinary := [w[1] : w in Factorization(fhCheckBinary)];
            factFCheck := [PR4!1];
            factFHCheck := [PR4!1];
            for q in henselLift do
                if PR2!q in factFCheckBinary then
                    Append(~factFCheck, q);
                end if;
                if PR2!q in factFHCheckBinary then
                    Append(~factFHCheck, q);
                end if;
            end for;
            fCheck := &*factFCheck;
            fhCheck := &*factFHCheck;
            hCheck := ExactQuotient(fhCheck, fCheck);
  
            // l'(x) //
            if IsZero(l) then
                lCheck := PR2!0;
            else      
                rho := ReciprocalPolynomial(ExactQuotient(l, Gcd(p, l)));
                factor1 := ReciprocalPolynomial(ExactQuotient(Gcd(p, l*PR2!g), Gcd(p, l)));
                factor2 := ReciprocalPolynomial(ExactQuotient(p, Gcd(p, l*PR2!g)));
                inverseRho1 := Modinv(rho, factor2);
                inverseRho2 := Modinv(rho, factor1*factor2);
                nu1 := x^Degree(l)*inverseRho1 mod factor2;
                nu2 := x^Degree(l)*inverseRho2 mod (factor1*factor2);
                m := Lcm(alpha,beta);
                lCheck := ExactQuotient(x^alpha - 1, ReciprocalPolynomial(p))*
                    (factor1*x^(m-Degree(f))*nu1 + factor2*x^(m-Degree(f)-Degree(h))*nu2);
                lCheck := lCheck mod pCheck;
            end if; 
        end if;
    end if;

    return <pCheck, lCheck, fCheck, hCheck>;

end intrinsic;  

/****************************************************************/
/*                                                              */
/* Function name: RandomZ2Z4CyclicCode                          */
/* Parameters: alpha, beta                                      */
/* Function description:  Given two non-negative integers alpha */
/*   and beta, with beta odd, return a random Z2Z4-additive     */
/*   cyclic code of type (alpha, beta; gamma, delta; kappa) and */
/*   a tuple containing the generator polynomials <p(x),l(x),   */
/*   f(x), h(x)>, where p(x), l(x) in Z2[x] and f(x), h(x) in   */
/*   Z4[x], such that p(x) divides x^alpha-1, deg(l(x)) <       */
/*   deg(p(x)), f(x) and h(x) are coprime divisors of x^beta-1, */
/*   and p(x) divides ((x^beta-1)/f(x))l(x) (mod 2).            */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : An even non-negative integer                      */
/* Output parameters description:                               */
/*   - A  Z2Z4-additive code                                    */
/*   - A tuple with the polynomials < p(x), l(x), f(x), h(x) >, */
/*      that is, the generator polynomials of the code          */
/*                                                              */
/* Remark: This function is based on the results given in the   */
/*   paper "Z2Z4-additive cyclic codes, generator polynomials,  */
/*   and dual codes" by J. Borges, C. Fernández-Córdoba, and R. */
/*   Ten-Valls in IEEE Transactions on Information Theory,      */
/*   vol. 62, no 11, 2016.                                      */
/*                                                              */  
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta)-> Z2Z4Code, */
/*                                                    Tup       */
/*                                                              */
/****************************************************************/ 
intrinsic RandomZ2Z4CyclicCode(alpha::RngIntElt, beta::RngIntElt) -> Z2Z4Code, Tup
{
 Given two non-negative integers alpha and beta, with beta odd, 
return a random Z2Z4-additive cyclic code of type 
(alpha, beta; gamma, delta; kappa) and a tuple containing the generator polynomials
 <p(x), l(x), f(x), h(x)>, where p(x), l(x) in Z2[x] and 
f(x), h(x) in Z4[x], such that p(x) divides x^alpha-1, 
deg(l(x)) < deg(p(x)), f(x) and h(x) are coprime divisors of x^beta-1,
and p(x) divides ((x^beta-1)/f(x))l(x) (mod 2).
}   
    require (alpha + beta) gt 0 : "Argument 1 and argument 2 cannot be both 0";
    require IsOdd(beta) : "Argument 2 must be odd";

    // quaternary random polynomials f and h //
    Z2FactorsBeta := [w[1] : w in Factorization(x^beta - 1)];
    Z4FactorsBeta := HenselLift(z^beta - 1, Z2FactorsBeta, PR4);
    f := PR4!1;
    h := PR4!1;
    // if randomFactor = 0 -> factor of f
    // if randomFactor = 1 -> factor of h
    // if randomFactor = 2 -> nothing (factor of g)
    for i in [1..#Z4FactorsBeta] do
        randomFactor := Random(2);
        if IsZero(randomFactor) then
            f := f*Z4FactorsBeta[i];
        elif IsOne(randomFactor) then
            h := h*Z4FactorsBeta[i];
        end if;
    end for;

    // binary random polynomials p and l //
    if (alpha gt 0) then
        factorsAlpha := Factorization(x^alpha - 1);
        p := PR2!1;
        l := PR2!1;
        for i in [1..#factorsAlpha] do
            p := IsOne(Random(1)) select p*factorsAlpha[i][1] else p;
            l := IsOne(Random(1)) select l*factorsAlpha[i][1] else l; 
        end for;

        // p divides ((y^beta - 1)/f)*l (mod 2)
        p := (beta gt 1) select Gcd(p, PR2!ExactQuotient(y^beta - 1, f)*l) else Gcd(p, l);
        // deg(l) < deg(p)
        l := l mod p;  
    else
        p := PR2!0;
        l := PR2!0;
    end if; 
    
    return Z2Z4CyclicCode(alpha, beta, p, l, f, h), <p, l, f, h>;

end intrinsic;


