/*************************************************************/
/*                                                           */
/* Package or project name: Z2Z4AdditiveCodes package        */
/* Test file name: Z2Z4CyclicCodes_BB_test.m                 */
/*                                                           */
/* Comments: Black-box tests for the intrinsic functions     */
/*        Z2Z4CyclicCode, IsCyclic, CheckPolynomial          */
/*        and GeneratorPolynomials included in the           */
/*        Z2Z4Cyclic.m file                                  */
/*                                                           */
/* Authors: Joaquim Borges, Cristina                         */
/*          Fernández-Córdoba and Roger Ten-Valls            */
/*          and suppervised by J. Pujol and M. Villanueva    */
/*                                                           */
/* Revision version and last date: v1.0, 2015/10/10          */
/*                                 v1.1, 2016/02/11          */
/*                                 v1.3, 2016/06/27          */
/*                                 v1.4, 2018/01/17          */
/*                                 v1.5, 2018/10/09          */
/*     User Defined type           v1.6  2019/02/01          */
/*                                                           */
/*************************************************************/

//needs Z2Z4AdditiveCode file
//needs Z2Z4StandardForm file
//needs Z2Z4Cyclic.m file

SetAssertions(true);
Alarm(30*60);

/****************************************************************
	GLOBAL VARIABLES
*****************************************************************/
Z2 := Integers(2);    
Z4 := Integers(4);
PR2<x> := PolynomialRing(Z2); 
PR4<y> := PolynomialRing(Z4);
PR := PolynomialRing(Integers());

/****************************************************************/
/*                                                              */
/* Function name: IsCyclic                                      */
/* Parameters: C                                                */
/* Function description: Return true if and only if the         */
/*   Z2Z4-additive code C is cyclic.                            */
/* Input parameters description:                                */
/*   - C : A Z2Z4-additive code                                 */
/* Output parameters description:                               */
/*   - Boolean, true if the Z2Z4-additive code is a cyclic code */
/*    and false otherwise.                                      */
/*                                                              */
/* Signature: (<Z2Z4Code> C) -> BoolElt                         */
/*                                                              */
/****************************************************************/  
/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters:  alpha, G                                        */
/* Function description: Given a non-negative integer alpha and */
/*   a non-empty sequence of r vectors G=[u_1,u_2,...,u_r],     */
/*   where,  for 1<= i<= r, u_i in Z2^alpha x Z4^beta is        */
/*   represented as an element in V=Z4^(alpha+beta) by changing */
/*   the ones in the first alpha coordinates by twos, construct */
/*   the Z2Z4-additive cyclic code of type (alpha, beta; gamma, */
/*   delta; kappa) generated by the double right cyclic shifts  */
/*   of the vectors u_1,u_2,...,u_r. It is checked whether the  */
/*   elements in the first alpha coordinates are in {0, 2}.     */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - G : A sequence of vectors over Z4                        */
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature:(<RngIntElt> alpha, <[ModTupRngElt]> G) -> Z2Z4Code*/
/*                                                              */
/****************************************************************/ 
/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: alpha, u                                         */
/* Function description: Given a non-negative integer alpha and */
/*   a vector u=(u_alpha | u_beta) in Z2^alpha x Z4^beta,       */
/*   represented as an element in V=Z4^(alpha+beta) by changing */
/*   the ones in the first alpha coordinates by twos, construct */
/*   the Z2Z4-additive cyclic code of type (alpha, beta; gamma, */
/*   delta; kappa) generated by the double right cyclic shifts  */
/*   of the vector u. It is checked whether the elements in the */
/*   first alpha coordinates are in {0, 2}.                     */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - u : A vector over Z4                                     */ 
/* Output parameters description:                               */
/*   - A  Z2Z4-additive code                                    */
/*                                                              */
/* Signature: (<RngIntElt> alpha, <ModTupRngElt> u) -> Z2Z4Code */
/*                                                              */
/****************************************************************/
/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: alpha, beta, G                                   */
/* Function description: Given two non-negative integers alpha  */
/*   and beta, and a non-empty sequence G containing r tuples   */
/*   of polynomials, that is  G=[< a_1(x), b_1(x)>,..., <a_r(x),*/
/*   b_r(x)>], where a_i(x) in Z2[x] and b_i(x) in Z4[x], for   */
/*   1<= i <= r, construct the Z2Z4-additive cyclic code of     */
/*   type (alpha, beta; gamma, delta; kappa) generated by       */
/*   (a_1(x) | b_1(x)),...,(a_r(x) | b_r(x)).                   */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : A non-negative integer                            */
/*   - G : A sequence of tuples of generator polynomials        */
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta, <[Tup]> G)  */
/*                 -> Z2Z4Code                                  */
/*                                                              */
/****************************************************************/ 
/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: alpha, beta, a, b                                */
/* Function description: Given two non-negative integers alpha  */ 
/*   and beta, and two polynomials a(x) in Z2[x] and b(x) in    */
/*   Z4[x], construct the Z2Z4-additive cyclic code of type     */
/*   (alpha, beta; gamma, delta; kappa) generated by            */
/*   (a(x) | b(x)).                                             */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : A non-negative integer                            */
/*   - a : A polynomial over Z2                                 */
/*   - b : A polynomial over Z4                                 */ 
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta,             */
/*             <RngUPolElt> a, <RngUPolElt> b) -> Z2Z4Code      */
/*                                                              */
/****************************************************************/  
/****************************************************************/
/*                                                              */
/* Function name: Z2Z4CyclicCode                                */
/* Parameters: alpha, beta, p, l, f, h                          */
/* Function description: Given two non-negative integers alpha  */
/*   and beta, and four polynomials p(x), l(x), f(x) and h(x),  */
/*   such that p(x), l(x) in Z2[x] and f(x), h(x) in Z4[x],     */
/*   construct the Z2Z4-additive cyclic code of type (alpha,    */
/*   beta; gamma, delta; kappa) generated by (p(x) | 0) and     */
/*   (l(x) | f(x)h(x) + 2f(x)).                                 */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : A non-negative integer                            */
/*   - p : A polynomial over Z2                                 */
/*   - l : A polynomial over Z2                                 */ 
/*   - f : A polynomial over Z4                                 */
/*   - h : A polynomial over Z4                                 */  
/* Output parameters description:                               */
/*   - A Z2Z4-additive code                                     */
/*                                                              */
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta,             */
/*             <RngUPolElt> p, <RngUPolElt> l, <RngUPolElt> f,  */
/*             <RngUPolElt> h) -> Z2Z4Code                      */
/*                                                              */
/****************************************************************/ 
/****************************************************************/
/*                                                              */
/* Function name: GeneratorPolynomials                          */
/* Parameters: C                                                */
/* Function description: Given a Z2Z4-additive cyclic code C of */
/*   type (alpha, beta; gamma, delta; kappa) with beta odd,     */
/*   return a tuple containing the generator polynomials        */
/*   < p(x), l(x), f(x), h(x) >, where p(x), l(x) in Z2[x] and  */
/*   f(x), h(x) in Z4[x], such that p(x) divides x^alpha - 1,   */
/*   deg(l(x)) < deg(p(x)), f(x) and h(x) are coprime divisors  */
/*   of x^beta-1, b(x) divides ((x^beta - 1)/f(x))l(x) (mod 2), */
/*   and C = < (p(x) | 0), (l(x) | f(x)h(x) + 2f(x)) >.         */
/* Input parameters description:                                */
/*   - C : A Z2Z4-additive cyclic code                          */
/* Output parameters description:                               */
/*   - A tuple with the polynomials < p(x), l(x), f(x), h(x) >, */
/*      that is, the generator polynomials of the code          */
/*                                                              */
/* Remark: This function is based on the results given in the   */
/*         following papers:                                    */  
/*   - "Z2Z4-additive cyclic codes, generator polynomials, and  */
/*     dual codes" by J. Borges, C. Fernández-Córdoba, and      */
/*     R. Ten-Valls in IEEE Transactions on Information Theory, */
/*     vol. 62, no 11, 2016.                                    */
/*   - "Computing the generator polynomials of Z2Z4-additive    */
/*     cyclic codes" y J. Borges, C. Fernández-Córdoba, and     */
/*     R. Ten-Valls, arXiv:1606.01745                           */
/*                                                              */
/* Signature: (<Z2Z4Code> C) -> Tup                             */
/*                                                              */
/****************************************************************/ 
/****************************************************************/
/*                                                              */
/* Function name: DualGeneratorPolynomials                      */
/* Parameters: C                                                */
/* Function description: Given a Z2Z4-additive cyclic code C of */
/*   type (alpha, beta; gamma, delta; kappa) with beta odd,     */
/*   return a tuple of polynomials <p'(x), l'(x), f'(x), h'(x)>,*/
/*   where p'(x), l'(x) in Z2[x] and f'(x), h'(x) in Z4[x], such*/
/*   that p'(x) divides x^alpha - 1, deg(l'(x)) < deg(p'(x)),   */
/*   f'(x) and h'(x) are coprime divisors of x^beta-1, p'(x)    */
/*   divides ((x^beta - 1)/f'(x))l'(x) (mod 2). These           */
/*   polynomials are the generator polynomials of the additive  */
/*   dual code of C.                                            */
/* Input parameters description:                                */
/*   - C : A Z2Z4-additive cyclic code                          */
/* Output parameters description:                               */
/*   - A tuple of polynomials <p'(x),l'(x),f'(x),h'(x)>,        */
/*      containing the generator polynomials of the additive    */
/*      dual of C.                                              */
/*                                                              */
/* Remark: This function is based on the results given in the   */
/*   paper "Z2Z4-additive cyclic codes, generator polynomials,  */
/*   and dual codes" by J. Borges, C. Fernández-Córdoba, and R. */
/*   Ten-Valls in IEEE Transactions on Information Theory,      */
/*   vol. 62, no 11, 2016.                                      */
/*                                                              */
/* Signature: (<Z2Z4Code> C) -> Tup                             */
/*                                                              */
/****************************************************************/ 
/****************************************************************/
/*                                                              */
/* Function name: DualGeneratorPolynomials                      */
/* Parameters: alpha, beta, p, l, f, h                          */
/* Function description: Given two non-negative integers alpha  */
/*   and beta, with beta odd, and four polynomials p(x), l(x),  */ 
/*   f(x) and h(x), such that p(x), l(x) in Z2[x] and f(x),     */
/*   h(x) in Z4[x], return a tuple of polynomials <p'(x), l'(x),*/
/*   f'(x), h'(x)>, where p'(x), l'(x) in Z2[x] and f'(x), h'(x)*/
/*   in Z4[x], such that p'(x) divides x^alpha - 1, deg(l'(x)) <*/
/*   deg(p'(x)), f'(x) and h'(x) are coprime divisors of        */
/*   x^beta-1 and p'(x) divides ((x^beta-1)/f'(x))l'(x) (mod 2).*/
/*   These polynomials are the generator polynomials of the     */
/*   additive dual code of C.                                   */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : A non-negative integer                            */
/*   - p : A polynomial over Z2                                 */
/*   - l : A polynomial over Z2                                 */ 
/*   - f : A polynomial over Z4                                 */
/*   - h : A polynomial over Z4                                 */  
/* Output parameters description:                               */
/*   - A tuple of polynomials < p'(x),l'(x),f'(x),h'(x) >,      */
/*      containing the generator polynomials of the additive    */
/*      dual of C.                                              */
/*                                                              */
/* Remark: This function is based on the results given in the   */
/*   paper "Z2Z4-additive cyclic codes, generator polynomials,  */
/*   and dual codes" by J. Borges, C. Fernández-Córdoba, and R. */
/*   Ten-Valls in IEEE Transactions on Information Theory,      */
/*   vol. 62, no 11, 2016.                                      */  
/*                                                              */
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta,             */
/*             <RngUPolElt> p, <RngUPolElt> l, <RngUPolElt> f,  */
/*             <RngUPolElt> h) -> Tup                           */
/*                                                              */
/****************************************************************/ 
/****************************************************************/
/*                                                              */
/* Function name: RandomZ2Z4CyclicCode                          */
/* Parameters: alpha, beta                                      */
/* Function description:  Given two non-negative integers alpha */
/*   and beta, with beta odd, return a random Z2Z4-additive     */
/*   cyclic code of type (alpha, beta; gamma, delta; kappa) and */
/*   a tuple containing the generator polynomials <p(x),l(x),   */
/*   f(x), h(x)>, where p(x), l(x) in Z2[x] and f(x), h(x) in   */
/*   Z4[x], such that p(x) divides x^alpha-1, deg(l(x)) <       */
/*   deg(p(x)), f(x) and h(x) are coprime divisors of x^beta-1, */
/*   and p(x) divides ((x^beta-1)/f(x))l(x) (mod 2).            */
/* Input parameters description:                                */
/*   - alpha : A non-negative integer                           */
/*   - beta : An even non-negative integer                      */
/* Output parameters description:                               */
/*   - A record representing a Z2Z4-additive code               */
/*   - A tuple with the polynomials < p(x), l(x), f(x), h(x) >, */
/*      that is, the generator polynomials of the code          */
/*                                                              */
/* Remark: This function is based on the results given in the   */
/*         paper "Z2Z4-additive cyclic codes, generator         */ 
/*         polynomials, and dual codes" by J. Borges,           */
/*         C. Fernández-Córdoba, and R. Ten-Valls in IEEE       */
/*         Transactions on Information Theory, vol. 62, no 11,  */
/*         2016.                                                */
/*                                                              */  
/* Signature: (<RngIntElt> alpha, <RngIntElt> beta)-> Z2Z4Code, */
/*                                                    Tup       */
/*                                                              */
/****************************************************************/
/*********************************************************************/
/* Codes of tests 1, 4, 5, 7, 8 and 11 are generated by one element, */
/* codes of tests 2, 3, 6, 9 and 10 are generated by two elements.   */
/* The codes generated by two elements cannot be genereted using the */
/* following intrinsics:                                             */
/*        - Z2Z4CyclicCode(alpha, u),                                */
/*        - Z2Z4CyclicCode(alpha, beta, a, b).                       */
/*                                                                   */
/*********************************************************************/
print "CYCLIC CODES";

print "test 1: Trivial Z2Z4-additive zero code
               alpha = 10, beta = 7, binary length = 24, #C = 0"; 

alpha := 10;
beta := 7;

expectedOutput := Z2Z4AdditiveZeroCode(alpha, beta);
assert IsCyclic(expectedOutput);

zero := RSpace(Z4, 17)!0;

Output := Z2Z4CyclicCode(alpha, [zero]);
assert Output eq expectedOutput;

Output := Z2Z4CyclicCode(alpha, zero);
assert Output eq expectedOutput;

a1 := PR2!0;
b1 := PR4!0;

Output := Z2Z4CyclicCode(alpha, beta, [<a1, b1>]);
assert Output eq expectedOutput;

Output := Z2Z4CyclicCode(alpha, beta, a1, b1);
assert Output eq expectedOutput;

p := x^10-1;
l := PR2!0;
f := y^7-1;
h := PR4!1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveZeroCode(alpha, beta));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 2: Trivial Z2Z4-additive universe code
               alpha = 15, beta = 3, binary length = 21, #C = 2097152"; 
               
alpha := 15;
beta := 3;

expectedOutput := Z2Z4AdditiveUniverseCode(alpha, beta);
assert IsCyclic(expectedOutput);

G := Matrix(Z4, 
   [[2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]]);

Output := Z2Z4CyclicCode(alpha, Rows(G));
assert Output eq expectedOutput;

a1 := PR2!1;
b1 := PR4!0;
a2 := PR2!1;
b2 := PR4!1;

Output := Z2Z4CyclicCode(alpha, beta, [<a1, b1>, <a2, b2>]);
assert Output eq expectedOutput;

p := PR2!1;
l := PR2!0;
f := PR4!1;
h := PR4!1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveUniverseCode(alpha, beta));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 3a: The order two Z2Z4-additive subcode of the Z2Z4-additive universe code 
               alpha = 6, beta = 11, binary length = 28, #C = 131072"; 

alpha := 6;
beta := 11;

expectedOutput :=  OrderTwoSubcode(Z2Z4AdditiveUniverseCode(alpha, beta));
assert IsCyclic(expectedOutput);

G := Matrix(Z4, 
   [[2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2]]);

Output := Z2Z4CyclicCode(alpha, Rows(G));
assert Output eq expectedOutput;

a1 := PR2!1;
b1 := PR4!0;
a2 := PR2!0;
b2 := y^11+1;

Output := Z2Z4CyclicCode(alpha, beta, [<a1,b1>, <a2,b2>]);
assert Output eq expectedOutput;

p := PR2!1;
l := PR2!0;
f := PR4!1;
h := y^11-1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials( OrderTwoSubcode(Z2Z4AdditiveUniverseCode(alpha, beta)));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 3b: The even weight Z2Z4-additive code 
               alpha = 4, beta = 9, binary length = 22, #C = 2097152"; 

alpha := 4;
beta := 9;

expectedOutput := Z2Z4AdditiveEvenWeightCode(alpha,beta);
assert IsCyclic(expectedOutput);

G := Matrix(Z4, 
   [[2,0,0,0,0,0,0,0,0,0,0,0,1],
    [0,2,0,0,0,0,0,0,0,0,0,0,1],
    [0,0,2,0,0,0,0,0,0,0,0,0,1],
    [0,0,0,2,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,1,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,1,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,1,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,1,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,1,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,1,0,0,1],
    [0,0,0,0,0,0,0,0,0,0,1,0,1],
    [0,0,0,0,0,0,0,0,0,0,0,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,2]]);

Output := Z2Z4CyclicCode(alpha, Rows(G));
assert Output eq expectedOutput;

a1 := PR2!1;
b1 := PR4!1;
a2 := PR2!0;
b2 := y^beta-1;

Output := Z2Z4CyclicCode(alpha, beta, [<a1,b1>, <a2,b2>]);
assert Output eq expectedOutput;

p := x+1;
l := PR2!1;
f := PR4!1;
h := PR4!1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(expectedOutput);
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 4: Repetition Z2Z4-additive code
               alpha = 4, beta = 7, binary length = 18, #C = 2"; 

alpha := 4;
beta := 7;
V := RSpace(Z4, 11);

expectedOutput := Z2Z4AdditiveRepetitionCode(alpha, beta);
assert IsCyclic(expectedOutput);

Output := Z2Z4CyclicCode(alpha, [V![2,2,2,2,2,2,2,2,2,2,2]]);
assert Output eq expectedOutput;

Output := Z2Z4CyclicCode(alpha, V![2,2,2,2,2,2,2,2,2,2,2]);
assert Output eq expectedOutput;

a1 := PR2!0;
b1 := PR4!0;
a2 := x^3+x^2+x+1;
b2 := y^7 + 2*y^6 + 2*y^5 + 2*y^4 + 2*y^3 + 2*y^2 + 2*y + 1;

Output := Z2Z4CyclicCode(alpha, beta, [<a1,b1>, <a2,b2>]);
assert Output eq expectedOutput;

Output := Z2Z4CyclicCode(alpha, beta, a2, b2);
assert Output eq expectedOutput;

p := PR2!x^4-1;
l := x^3+x^2+x+1;
f := y^6+y^5+y^4+y^3+y^2+y+1;
h := y-1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveRepetitionCode(4,7));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 5: A Z2Z4-additive cyclic code with polynomial p(x)=x^alpha-1
               alpha = 2, beta = 3, binary length = 8, #C = 16"; 

alpha := 2;
beta := 3;
V := RSpace(Z4, 5);
M := Matrix(Z4,[
        [2,2,3,1,1],
        [0,0,2,2,0],
        [0,0,0,2,2]]);

expectedOutput := Z2Z4AdditiveCode(M, alpha);
assert IsCyclic(expectedOutput);

Output := Z2Z4CyclicCode(alpha, Rows(M));
assert Output eq expectedOutput;

u := V ! [2,2,3,1,1];

Output := Z2Z4CyclicCode(alpha, u);
assert Output eq expectedOutput;

a1 := x^2-1;
b1 := PR4!0;
a2 := x+1;
b2 := y^2 + y + 3;

Output := Z2Z4CyclicCode(alpha, beta, [<a1, b1>, <a2, b2>]);
assert Output eq expectedOutput;

Output := Z2Z4CyclicCode(alpha, beta, a2, b2);
assert Output eq expectedOutput;

p := x^2-1;
l := x+1;
f := PR4!1;
h := y^2+y+1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveCode(M, alpha));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 6: A Z2Z4-additive cyclic code with polynomial l(x)=0
               alpha = 7, beta = 5, binary length = 17, #C = 32"; 

alpha := 7;
beta := 5;
V := RSpace(Z4, 12);
M := Matrix(Z4,[
        [2,2,0,2,0,0,0,0,0,0,0,0],
        [0,2,2,0,2,0,0,0,0,0,0,0],
        [0,0,2,2,0,2,0,0,0,0,0,0],
        [0,0,0,2,2,0,2,0,0,0,0,0],
        [0,0,0,0,0,0,0,2,2,2,2,2]]);

expectedOutput := Z2Z4AdditiveCode(M, alpha);
assert IsCyclic(expectedOutput);

Output := Z2Z4CyclicCode(alpha, Rows(M));
assert Output eq expectedOutput;

a1 := x^3 + x + 1;
b1 := PR4 ! 0;
a2 := PR2 ! 0;
b2 := 2*y^4 + 2*y^3 + 2*y^2 + 2*y + 2;

Output := Z2Z4CyclicCode(alpha, beta, [<a1, b1>, <a2, b2>]);
assert Output eq expectedOutput;

p := x^3 + x + 1;
l := PR2!0;
f := y^4 + y^3 + y^2 + y + 1;
h := y - 1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveCode(M, alpha));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 7: A Z2Z4-additive cyclic code with alpha = 0
               alpha = 0, beta = 21, binary length = 42, #C = 1048576"; 

alpha := 0;
beta := 21;
V := RSpace(Z4, 21);
M := Matrix(Z4,[
        [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 3, 2],
        [0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 3, 1, 1],
        [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 3, 2, 1],
        [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2],
        [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],
        [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],
        [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 2 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,2 ,2 ,0],
        [0, 0, 0 ,0, 0, 0, 0, 0, 0 ,0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2],
        [0, 0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0 ,2, 0, 0, 0 ,0 ,0 ,0 ,2 ,0 ,0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0],
        [0, 0, 0, 0, 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,2 ,0 ,0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0 ,0 ,0 ,0, 0, 0, 0, 0, 0 ,2 ,0 ,0 ,0 ,2 ,0, 2],
        [0, 0, 0, 0 ,0 ,0 ,0, 0 ,0, 0, 0, 0 ,0 ,0, 0, 2 ,0 ,0 ,2, 2, 2],
        [0, 0, 0, 0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0 ,0, 0, 0, 2, 0, 2, 2, 0],
        [0, 0, 0 ,0 ,0, 0, 0, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2]]);

expectedOutput := Z2Z4AdditiveCode(M, alpha);
assert IsCyclic(expectedOutput);

Output := Z2Z4CyclicCode(alpha, Rows(M));
assert Output eq expectedOutput;

u := V ! [3, 1, 1, 0, 1, 0, 0, 1, 1, 3, 2, 1, 0, 0, 1, 1, 3, 2, 1, 0, 0];

Output := Z2Z4CyclicCode(alpha, u);
assert Output eq expectedOutput;

a1 := PR2!0;
b1 := PR4!0;
a2 := PR2!0;
b2 := y^18 + 2*y^17 + 3*y^16 + y^15 + y^14 + y^11 + 2*y^10 + 3*y^9 + y^8 + y^7 
    + y^4 + y^2 + y + 3;

Output := Z2Z4CyclicCode(alpha, beta, [<a1,b1>, <a2,b2>]);
assert Output eq expectedOutput;

Output := Z2Z4CyclicCode(alpha, beta, a2, b2);
assert Output eq expectedOutput;

p := PR2!0;
l := PR2!0;
f := y^3 + 3*y^2 + 2*y + 3;
h := y^15 + 3*y^14 + y^8 + 3*y^7 + y + 3;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveCode(M, alpha));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 8: A Z2Z4-additive cyclic code with f(x)=x^beta-1, h(x)=1 and l(x)=0
               alpha = 9, beta = 5, binary length = 19, #C = 4"; 

alpha := 9;
beta := 5;
V := RSpace(Z4, 14);
M := Matrix(Z4,[
        [2, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0],
        [0, 2, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0]]);

expectedOutput := Z2Z4AdditiveCode(M, alpha);
assert IsCyclic(expectedOutput);

Output := Z2Z4CyclicCode(alpha, Rows(M));
assert Output eq expectedOutput;

u := V ! [2, 2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0];

Output := Z2Z4CyclicCode(alpha, u);
assert Output eq expectedOutput;

a1 := x^7 + x^6 + x^4 + x^3 + x + 1;
b1 := PR4 ! 0;

Output := Z2Z4CyclicCode(alpha, beta, [<a1, b1>]);
assert Output eq expectedOutput;

Output := Z2Z4CyclicCode(alpha, beta, a1, b1);
assert  Output eq expectedOutput;

p := x^7 + x^6 + x^4 + x^3 + x + 1;
l := PR2!0;
f := y^5-1;
h := PR4! 1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert  Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveCode(M, alpha));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 9: A Z2Z4-additive cyclic code with h(x)=x^beta-1
               alpha = 3, beta = 9, binary length = 21, #C = 1024"; 

alpha := 3;
beta := 9;
V := RSpace(Z4, 12);
M := Matrix(Z4,[
        [2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0],
        [2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],
        [0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],
        [0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0],
        [2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],
        [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],
        [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2]]);

expectedOutput := Z2Z4AdditiveCode(M, alpha);
assert IsCyclic(expectedOutput);

Output := Z2Z4CyclicCode(alpha, Rows(M));
assert  Output eq expectedOutput;

a1 := x^2 + x + 1;
b1 := PR4 ! 0;
a2 := PR2 ! 1;
b2 := PR4 ! 2;

Output := Z2Z4CyclicCode(alpha, beta, [<a1,b1>, <a2,b2>]);
assert  Output eq expectedOutput;

p := x^2 + x + 1;
l := PR2!1;
f := PR4! 1;
h := y^9 - 1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert  Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveCode(M, alpha));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 10: A Z2Z4-additive cyclic code
               alpha = 15, beta = 7, binary length = 25, #C = 1048576"; 

alpha := 15;
beta := 7;
M := Matrix(Z4,[
        [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2],
        [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2],
        [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1]]);

expectedOutput := Z2Z4AdditiveCode(M, alpha);
assert IsCyclic(expectedOutput);

Output := Z2Z4CyclicCode(alpha, Rows(M));
assert  Output eq expectedOutput;

a1 := x^5 + x^3 + x + 1;
b1 := PR4 ! 0;
a2 := x^4 + x^3 + 1;
b2 := y^4 + y^3 + 3*y^2 + 2*y + 3;

Output := Z2Z4CyclicCode(alpha, beta, [<a1,b1>, <a2,b2>]);
assert  Output eq expectedOutput;

p := x^5 + x^3 + x + 1;
l := x^4 + x^3 + 1;
f := PR4 ! 1;
h := y^4 + y^3 + 3*y^2 + 2*y + 1;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert  Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveCode(M, alpha));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 11: A Z2Z4-additive cyclic code with beta = 0
               alpha = 7, beta = 0, binary length = 7, #C = 16"; 

alpha := 7;
beta := 0;
V := RSpace(Z4, 7);
M := Matrix(Z4, [[2, 0, 0, 0, 2, 2, 0],
                 [0, 2, 0, 0, 0, 2, 2],
                 [0, 0, 2, 0, 2, 2, 2],
                 [0, 0, 0, 2, 2, 0, 2]]);

expectedOutput := Z2Z4AdditiveCode(M, alpha);
assert IsCyclic(expectedOutput);

Output := Z2Z4CyclicCode(alpha, Rows(M));
assert  Output eq expectedOutput;

u := V ! [0, 0, 0, 2, 2, 0, 2];

Output := Z2Z4CyclicCode(alpha, u);
assert  Output eq expectedOutput;

a1 := x^3 + x + 1;
b1 := PR4 ! 0;

Output := Z2Z4CyclicCode(alpha, beta, [<a1, b1>]);
assert  Output eq expectedOutput;

Output := Z2Z4CyclicCode(alpha, beta, a1, b1);
assert  Output eq expectedOutput;
               
p := x^3 + x + 1;
l := PR2 ! 0;
f := PR4 ! 0;
h := PR4 ! 0;

Output := Z2Z4CyclicCode(alpha, beta, p, l, f, h);
assert  Output eq expectedOutput;

expectedOutputPol := <p, l, f, h>;
OutputPol :=  GeneratorPolynomials(Z2Z4AdditiveCode(M, alpha));
assert expectedOutputPol eq OutputPol;

OutputDual :=  Dual(Output);
expectedOutputCheckPol :=  GeneratorPolynomials(OutputDual);

OutputCheckPol :=  DualGeneratorPolynomials(Output);
assert expectedOutputCheckPol eq OutputCheckPol;

OutputCheckPol :=  DualGeneratorPolynomials(alpha, beta, p, l, f, h);
assert expectedOutputCheckPol eq OutputCheckPol;

/*********************************************************************/
print "test 12: A random Z2Z4-additive cyclic code with alpha = 0";

alpha := 0;
beta := 7;

OutputCode, OutputPol := RandomZ2Z4CyclicCode(alpha, beta);
expectedOutputPol :=  GeneratorPolynomials(OutputCode);

assert IsZ2Z4AdditiveCode(OutputCode);
assert IsCyclic(OutputCode);
assert Z2Z4Type(OutputCode)[1] eq alpha;
assert Z2Z4Type(OutputCode)[2] eq beta;
assert expectedOutputPol eq OutputPol;

/*********************************************************************/
print "test 13: A random Z2Z4-additive cyclic code with beta = 1";

alpha := 5;
beta := 1;

OutputCode, OutputPol := RandomZ2Z4CyclicCode(alpha, beta);
expectedOutputPol :=  GeneratorPolynomials(OutputCode);

assert IsZ2Z4AdditiveCode(OutputCode);
assert IsCyclic(OutputCode);
assert Z2Z4Type(OutputCode)[1] eq alpha;
assert Z2Z4Type(OutputCode)[2] eq beta;
assert expectedOutputPol eq OutputPol;

/*********************************************************************/
print "test 14: A random Z2Z4-additive cyclic code with alpha > beta > 0";

alpha := 7;
beta := 3;

OutputCode, OutputPol := RandomZ2Z4CyclicCode(alpha, beta);
expectedOutputPol :=  GeneratorPolynomials(OutputCode);

assert IsZ2Z4AdditiveCode(OutputCode);
assert IsCyclic(OutputCode);
assert Z2Z4Type(OutputCode)[1] eq alpha;
assert Z2Z4Type(OutputCode)[2] eq beta;
assert expectedOutputPol eq OutputPol;

/*********************************************************************/
print "test 15: A Z2Z4-additive cyclic code with beta > alpha > 0";

alpha := 6;
beta := 9;

OutputCode, OutputPol := RandomZ2Z4CyclicCode(alpha, beta);
expectedOutputPol :=  GeneratorPolynomials(OutputCode);

assert IsZ2Z4AdditiveCode(OutputCode);
assert IsCyclic(OutputCode);
assert Z2Z4Type(OutputCode)[1] eq alpha;
assert Z2Z4Type(OutputCode)[2] eq beta;
assert expectedOutputPol eq OutputPol;


